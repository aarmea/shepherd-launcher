#!/usr/bin/env bash

set -e

# Set up dev runtime directory
DEV_RUNTIME="./dev-runtime"
DATA_DIR="$DEV_RUNTIME/data"
SOCKET_PATH="$DEV_RUNTIME/shepherd.sock"

mkdir -p "$DATA_DIR"

# Kill any existing shepherd dev instances before starting
echo "Cleaning up any existing dev instances..."
pkill -f "sway -c ./sway.conf" 2>/dev/null || true
pkill -f "shepherdd" 2>/dev/null || true
pkill -f "shepherd-launcher" 2>/dev/null || true
pkill -f "shepherd-hud" 2>/dev/null || true
# Remove stale socket
rm -f "$SOCKET_PATH"
sleep 0.5

# Export environment variables for shepherd binaries
export SHEPHERD_SOCKET="$SOCKET_PATH"
export SHEPHERD_DATA_DIR="$DATA_DIR"

# Note: Since shepherdd now runs inside sway, spawned apps automatically
# use the nested compositor's display. No SHEPHERD_WAYLAND_DISPLAY override needed.

# Build all binaries
echo "Building shepherd binaries..."
cargo build

# Function to cleanup background processes on exit
cleanup() {
    echo "Cleaning up..."
    # Kill the nested sway - this will clean up everything inside it (including shepherdd)
    if [ ! -z "$SWAY_PID" ]; then
        kill $SWAY_PID 2>/dev/null || true
    fi
    # Also explicitly kill any shepherd processes that might have escaped
    pkill -f "shepherdd" 2>/dev/null || true
    pkill -f "shepherd-launcher" 2>/dev/null || true
    pkill -f "shepherd-hud" 2>/dev/null || true
    # Remove socket
    rm -f "$SOCKET_PATH"
}
trap cleanup EXIT

# Note: shepherdd is started by sway.conf so it runs INSIDE the nested compositor.
# This ensures all spawned processes (games, apps) use the nested compositor's display.

# Start sway with the launcher and HUD
# The HUD and launcher are started by sway.conf so they run INSIDE the nested compositor
echo "Starting nested sway with shepherd-launcher..."
WLR_BACKENDS=wayland WLR_LIBINPUT_NO_DEVICES=1 sway -c ./sway.conf &
SWAY_PID=$!

# Wait for sway to exit
wait $SWAY_PID
